// Importamos MÃ³dulos de node
const {
    converterPath,
    validatePath,
    fileSearch,
    readFilesContent,
    httpPetitionStatus,
  } = require('./node-methods.js');
  
  //--------- Se importa LibrerÃ­a chalk --------- ðŸ‘‡
  const chalk = require('chalk');
  
  //--------- FunciÃ³n mdLinks ðŸ‘‡ ---------
  const mdLinks = (path, options = {validate:false}) => new Promise((resolve, reject) => {
  
  //--------- convertir ruta capturada en absoluta ðŸ‘‡ ---------
      const pathAbsolute = converterPath(path);
  //--------- Guardo el rersultado e invoco la funciÃ³n pasando como argumento pathAbsolute ðŸ‘‡---------
      const resultValidatePath = validatePath(pathAbsolute);
  
      //--------- Condicional que valida la ruta y la recursividad invocando la funciÃ³n fileSearch desde nodeMethods ðŸ‘‡---------
      let arrayFilePathMd = [];
      if(resultValidatePath === false){
        reject(chalk.redBright('| | âœ§ âœ¿ ...La ruta ingresada no es vÃ¡lida... âœ¿ âœ§ | |'))
      }else if(resultValidatePath){
        const filesMd = fileSearch(arrayFilePathMd, pathAbsolute) // ðŸ‘ˆ invocamos la funciÃ³n que nos da la recursividad
        if (filesMd.length === 0){
          reject(chalk.red.bold('| | âœ§ âœ¿ ...No hay archivos md encontrados o el archivo no es md... âœ¿ âœ§ | |'));
          }else{
            readFilesContent(arrayFilePathMd) //ðŸ‘ˆ Invocamos la funcion readFiles 
            .then((objectLinks)=>{
              if (objectLinks.length === 0) {
                reject(chalk.red.bold('| | âœ§ âœ¿ ...No se han encontrado links dentro del archivo md... âœ¿ âœ§ | |'));
              } else {
                if (options.validate === true) {
                  httpPetitionStatus(objectLinks).then(response => {
                    resolve(response)
    
                  })
                } else {
                  resolve(objectLinks);
                }
              }
            })
          }
      }
  
    });
  
  module.exports = mdLinks;